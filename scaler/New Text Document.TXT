Game of Prefixes

Problem Description

Two persons are playing a word game where players alternate appending letters to a word. The person who spells out a word, or creates a prefix for which there is no continuation possible, loses.

Given a dictionary of words denoted by string array A, determine the letters the first player should start with, such that with the optimal play they cannot lose.

NOTE: If no letter satisfies the above condition, return a character array with only character '0'.



Problem Constraints

1 <= length of A <= 105

1 <= Sum of length of all words <= 106

Words consist of only lowercase letters



Input Format

First and only argument is a string array A.


Output Format

Return a character array denoting the letters as described above in lexicographically sorted order.


Example Input

Input 1:

 A = ["cat", "calf", "dog", "bear"]

Input 2:

 A = ["ace", "act"]



Example Output

Output 1:

 ['b', 'c']

Output 2:

 ['0']



Example Explanation

Explanation 1:

 If first player chooses letter 'b' or 'c' and plays optimally, first player wins the game.

Explanation 2:

 There is no character such that first player wins the game. Return ['0']



*************************************************************************************


struct Trie {
	char val;
	set<Trie *> children;
	Trie(char val) {
		this->val = val;
	}
};

void insert(Trie* node, string& str, int index) {
	int n = str.size();
	if (n == index)
		return;
	char val = str[index];
	bool found = false;
	for (auto it = node->children.begin(); it != node->children.end(); ++it) {
		if ((*it)->val == val) {
			found = true;
			insert(*it, str, index + 1);
			break;
		}
	}
	if (found == false) {
		Trie *new_node = new Trie(val);
		node->children.insert(new_node);
		insert(new_node, str, index + 1);
	}
}
bool can_win(Trie* node, int chance) {
	if (node->children.size() == 0) {
		return chance ^ 1;
	}
	int winner = chance ;
	for (auto it = node->children.begin(); it != node->children.end(); ++it) {
		bool ans = can_win(*it, chance ^ 1);
		if (chance == 1) 
			winner &= ans;
		else
			winner |= ans;
	}
	return winner;
}
vector<char> Solution::solve(vector<string> &words) {
    int n = words.size();
	Trie* root = new Trie('@');
	for (string &str : words) {
		insert(root,str,0);
	}
	vector<char> winning_alphabets;
	for (char i = 'a'; i <= 'z'; ++i) {
		for (auto it = root->children.begin(); it != root->children.end(); ++it) {
			if ((*it)->val == i) {
				if (can_win(*it, 1)) {
					winning_alphabets.push_back(i);
				}
			}
		}
	}
	if (winning_alphabets.empty()) {
		winning_alphabets.push_back('0');
	}
	sort(winning_alphabets.begin(), winning_alphabets.end());
	return winning_alphabets;
}
